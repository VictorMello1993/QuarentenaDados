# -*- coding: utf-8 -*-
"""QuarentenaDados - aula02

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-LfPDw_7TKf8zPg7lXWf65EO7NhTypSD

#Aula 01

## Introdução

Olá seja bem-vinda ou bem-vindo ao **notebook da aula01**, nesta aula vamos realizar nossa primeira análise de dados e no final já seremos capazes de tirar algumas conclusões.

Nós estaremos desenvolvendo nosso projeto aqui no google colaboratory, assim podemos mesclar células contendo textos em formato markdown e células de código, além disso você não precisar instalar nada na sua máquina. Então que tal começar testando algumas linhas de código.

Nesta primeira célula estamos realizando um ```print()```, lembre-se que esta função python imprime a string que estamos passando como parâmetro, então  o retorno é exibido logo abaixo da célula com código.
"""

print("Guilherme Silveira")
print("Paulo Silveira")

"""Agora vamos analisar a proxima célula de código. 

Aqui estamos fazendo uma atribuição de variável, conforme dito em aula, as atribuições não tem retorno, assim, diferente da célula anterior não temos um *output* logo abaixo do código.
"""

nome_do_filme = "Totoro, o filme"

"""Agora que criamos a variável ```nome_do_filme```, podemos reutilizá-la, por exemplo na função ```print```, para assim imprimir a *string* "Totoro, o filme"."""

print(nome_do_filme)

nome_do_filme

"""## Lendo os dados do MovieLens

Nosso primeiro passo foi conhecer e realizar um "hello-world" no colab, agora chegou a hora de importar os dados para o notebook e começar as análises.

Vamos importar a biblioteca [pandas](https://pandas.pydata.org/), um poderoso projeto open source para análise de manipulação de dados. O primeiro passo é ler uma base de dados e podemos fazer isso com o comando ```pd.read_csv()```.

Estamos lendo um arquivo **CSV** (Comma-separated values), neste tipo de arquivo os valores são separados por vírgulas e podem ser abertos em outras ferramentas como excel e google-sheet. CSV não é o único formato lido pelo pandas, temos o ```pd.read_excel()``` que lê arquivos **xlsx** entre diversos outros formatos, você pode encontrar mais informações na seção de [input/output da documentação](https://pandas.pydata.org/pandas-docs/stable/reference/io.html).

Depois de ler o dataset, nós trocamos os nomes das colunas pelos termos em português, logo em seguida utilizamos o método ```filmes.head()``` para visualizar as primeiras 5 linhas do nosso dataframe. Outra forma de visualizar as informações dos dados é utilizando o método ```filmes.sample()```, se você tentar, vai verificar que ele retorna uma linha aleatória do seus dados. Para escolher aleatoriamente mais de 1 linha, por exemplo 5, é só passar esse valor desejado como parâmetro (```filmes.sample(5)```).
"""

import pandas as pd

filmes = pd.read_csv("https://raw.githubusercontent.com/alura-cursos/introducao-a-data-science/master/aula0/ml-latest-small/movies.csv")
# filmes é um DataFrame
filmes.columns = ["filmeId", "titulo", "generos"]
filmes.head()

"""Há pouco falamos para consultar a documentação para obter mais informações, mas será que é realmente preciso sair do notebook para tirar algumas dúvidas mais simples? 

Os notebooks facilitam a nossa vida podendo consultar o docstring das funções e métodos, rodando a célula com um **?** na frente da chamada, uma view é aberta com as informações resumidas. Veja a seguir alguns exemplos.
"""

# lendo a documentação de um método/atributo

?filmes.head

# lendo a documentação do tipo (docstring)

?filmes

"""A base de dados que usamos até o momento contém o nome do filme, ano de lançamento e gêneros. O MovieLens conta com outras informações que estão em bases separadas, uma delas é a de avaliações. 

Agora vamos analisar um pouco melhor o dataset de avaliações.
"""

avaliacoes = pd.read_csv("https://github.com/alura-cursos/introducao-a-data-science/blob/master/aula0/ml-latest-small/ratings.csv?raw=true")
avaliacoes.head()

"""Para visualizar algumas linhas estamos usando o ```.head()```, como ela mostra apenas as 5 primeiras linhas não sabemos qual é a quantidade de linhas que temos. Para descobrir a "forma" dos nossos dados podemos utilizar o ```avaliacoes.shape```, retornando uma [tupla](https://www.alura.com.br/artigos/conhecendo-as-tuplas-no-python), onde o primeiro termo indica o número de linhas e o segundo o número de colunas."""

avaliacoes.shape

len(avaliacoes)

"""Vamos substituir os nomes das colunas de inglês para português e entender o que são essas colunas. 

usarioId => ID para usuário que votou em determinado filme.

filmeId => ID para identificar um filme votado.

nota => A nota dada para pelo usuário para o respectivo filme.

momento => A data da votação que não está formatada como data

Como cada linha contém um voto para o respectivo filme é de se esperar que um filme tenha diversos votos, mas repare que nas 5 primeiras linhas temos o filme **1, 3, 6, 47, 50**. Mas e se eu quiser analisar apenas as notas do filme 1, como posso separar essa informação?
"""

avaliacoes.columns = ["usuarioId", "filmeId", "nota", "momento"]
avaliacoes.head()

"""Uma forma para "separar" as informações apenas do **filmeId 1** é chamando o método ```avaliacaoes.query("filmeId==1")```, esse método retornará apenas as linhas para quais a expressão booleana, "filmeId==1", for verdadeira.

Tendo as informações do **filmeId 1** podemos chamar o ```avaliacoes_do_filme_1.describe()```, para analisar as estatítiscas gerais dos dados.
"""

avaliacoes_do_filme_1 = avaliacoes.query("filmeId==1")
avaliacoes_do_filme_1.head()

avaliacoes_do_filme_1.describe()

"""Caso queira uma estatística particular, podemos apenas chamar o método desajado, repare abaixo como calculamos apenas a média das avaliações do **filmeId 1**."""

avaliacoes_do_filme_1.mean()

"""Calculamos as estatísicas apenas para o **filmeId 1**, mas também podemos chamar o método ```.describe()``` para a base completa (avaliacões)."""

avaliacoes.describe()

"""Ok, nós calculamos um tanto de coisa usando `.describe()` e `.mean()`, mas a informação que realmente queremos é a média da nota. Então o ponto é, como calcular a média apenas das notas?

A primeira coisa que precisamos fazer é selecionar apenas as informações de notas. Usando uma estrutura muito parecida com a de [chave-valor dos dicionários python](https://www.alura.com.br/artigos/trabalhando-com-o-dicionario-no-python). 

Com o comando ```avaliacoes["nota"]```, obtemos os valores da coluna nota (repare que o tipo retornado é uma Série pandas, por isso o index de cada nota é mantido). Para calcular a média de todas as notas executamos ```avaliacoes["notas"].means()```
"""

avaliacoes["nota"]

avaliacoes["nota"].mean()

"""Podemos calcular também na nota média do **filmeId 1**, repare que o resultado é um pouco maior que a geral. Apenas com essa análise não da para bater o martelo que o filme 1 é acima da média, mas apenas com essa análise conseguimos formular uma primeira hipótese!"""

avaliacoes_do_filme_1["nota"].mean()

"""Nós calculamos uma média geral, uma média para o filmeId 1. Agora eu quero calcular a média das notas para todos os filmes, podemos fazer isso usando o método ```.groupby(filmeId)```, o parâmetro passado é para indicar qual coluna ele deve utilizar para "agrupar" os dados. Depois só calcular a média como fizemos anteriormente."""

notas_medias_por_filme = avaliacoes.groupby("filmeId")["nota"].mean()
notas_medias_por_filme.head()

"""Temos as notas médias calculadas, mas agora precisamos juntar as informações de notas médias com a base de dados **filmes**.

Poderíamos criar uma nova coluna e atribuir a váriável `notas_medias_por_filme`, de forma direta:

```filmes["nota_media"] = notas_medias_por_filme```

Como discutimos em aula, essa não é uma boa prática pois precisamos garantir que a nota média seja do respectivo filme.

Para garantir essa condição vamos utilizar o ```.join()```, criando um novo dataframe (```filmes_com_media = filmes.join(notas_medias_por_filme, on="filmeId")```). 

Veja como fazer, nas células a seguir.
"""

filmes

notas_medias_por_filme

filmes_com_media = filmes.join(notas_medias_por_filme, on="filmeId")
filmes_com_media.head()

"""Agora que temos as médias, que tal visualizar o nosso dataframe ordenado pela nota de forma decrescente?"""

filmes_com_media.sort_values("nota", ascending=False).head(15)

"""Fizemos um tanto de análise e manipulação de dados interessante, não é?

Mas diz a verdade, você está sentindo falta daquele gráfico que todo cientista de dados adora =D, então bora plotar nosso primeiro gráfico!

O pandas facilita muito o plot de alguns gráficos simples, apenas selecionamos a informação que gostaríamos de visualizar e chamamos o método ```.plot()```
"""

avaliacoes.query("filmeId == 1")["nota"].plot()

"""Por padrão o método plotou um gráfico de linhas, o que não é adequado para os dados que estamos analisando.

Precisamos mudar o tipo de gráfico para realizar uma análise mais adequada, para fazer isso apenas alteramos o parâmetro **kind** do método ```.plot```. Vamos plotar um [histograma](https://pt.wikipedia.org/wiki/Histograma) rodando a célula a seguir.
"""

avaliacoes.query("filmeId == 1")["nota"].plot(kind='hist')

"""Legal, agora temos uma visualização muito mais agradavel de analisar. Compare com o gráfico de linhas, qual você acha melhor para análise? 

P.S: Deixar de usar o gráfico de linhas, não significa que sejá uma visualização ruim. Apenas quer dizer que nossos dados não tem características ideias para serem visualizados como um *line plot*, agora pense em uma [série temporal](https://pt.wikipedia.org/wiki/S%C3%A9rie_temporal). **Você acha que o gráfico de linhas ainda seria uma má ideia?**

Antes de analisar o histograms de outros filmes, quero colocar um título na imagem. Vamos ver como podemos fazer isso!
"""

avaliacoes.query("filmeId == 1")["nota"].plot(kind='hist',
                                              title="Avaliações do filme Toy Story")

"""Claro que python tem outras ferramentas muito poderosas para manipular gráficos, uma delas é o [matplotlib](https://matplotlib.org/).

Que tal experimentar um pouquinho esta poderosa ferramenta? 

Vamos importar a lib e adicionar título no gráfico usando o matplotlib, veja como fica na célula a seguir.
"""

import matplotlib.pyplot as plt

avaliacoes.query("filmeId == 1")["nota"].plot(kind='hist')
plt.title("Avaliações do filme Toy Story")
plt.show()

"""Agora que aprendemos a criar um histograma e manipular os gráficos, vamos plotar informações de outros filmes e realizar uma análise desses gráficos?

Vamos plotar o histograma do filme Jumanji e da animação Liga da justiça: Doom.
"""

avaliacoes.query("filmeId == 2")["nota"].plot(kind='hist',
                                              title="Avaliações do filme Toy Jumanji")

avaliacoes.query("filmeId == 102084")["nota"].plot(kind='hist',
                                                   title="Avaliações do filme Justice League: Doom")

"""Agora que temos os gráficos, chegou a hora de analisar.

A primeira coisa que preciso saber é o que cada eixo do meu gráfico significa. Então, eixo **x** mostra a nota, enquanto eixo **y** a frequência das notas (quantas vezes determinada nota foi dada). 

Entendido nosso gráfico, vamos contextualizar o cenário que estamos analisando:

 - Temos 3 filmes, dois muito populares (Toy story e Jumanji) e outro que nenhuma pessoa presente no momento da aula conhecia (animação da liga da justiça). O ponto que chamou a atenção, foi que a animação tinha média de nota maior que dois filmes, aparentemente mais popular, Jumaji e Toy Story. **Será que a animação é um filme tão bom assim?**


Dado esse cenário a primeira coisa que me chama a atenção é a animação da liga da justiça ter média de nota igual a 5. Ao analisar o histograma do respectivo filme, verificamos que ele só teve uma avaliação igual a 5, logo, fica evidente que a **quantidade de votos é um aspecto importante na avaliação das médias**. Com apenas uma avaliação, não conseguimos garantir que o filme é realmente bom, tornando a avaliação muito "volátil". Imagina que Liga da Justiça receba mais uma avaliação, com nota 0, assim a média seria 2.5. Apenas com mais essa avaliação o filme passaria a ser considerada um "pior" que Jumanji e Toy Story.

Outro ponto interessante é comparar o histograma de Toy Story e Jumanji, ambos tem médias "relativamente próximas". Mas repare que a distribuição de notas são diferentes, Toy Story recebe mais notas 5 e 4 que qualquer outra nota, enquanto Jumanji recebe mais notas 4 e 3, assim concluímos que a **distribuição das notas também é um fator importante na avaliação das médias**.(Se ficar alguma dúvida sobre esse tema reveja o exemplo que o instrutor apresenta no final na aula) 


Com isso nós fechamos a nossa primeira aula do **#quarentenadados**, viu quanta coisa aprendemos? Que tal colocar isso em prática?


**Crie seu próprio notebook, reproduza nossa aula e resolva os desafios que deixamos para vocês**.


Até a próxima aula!

## Desafio 1 do [Paulo Silveira](https://twitter.com/paulo_caelum)

O Paulo fez uma análise rápida e disse que tem 18 filmes sem avaliações, será que ele acertou?

Determine quantos filmes não tem avaliações e quais são esses filmes.
"""

filmes_com_avaliacao = pd.merge(filmes, notas_medias_por_filme, how='left', on=["filmeId"])
filmes_com_avaliacao.head()

filmes_com_avaliacao['nota'].isnull().value_counts() #Número de filmes sem nota = 18

filmes_sem_avaliacao = filmes_com_avaliacao['nota'].isnull()
filmes_com_avaliacao[filmes_sem_avaliacao] #Obtendo um dataframe de filmes sem nota

"""## Desafio 2 do [Guilherme Silveira](https://twitter.com/guilhermecaelum)

Mudar o nome da coluna nota do dataframe **filmes_com_media** para nota_média após o join.
"""

filmes_com_media = filmes_com_media.rename(columns={'nota':'nota_media'}) #Renomeando a coluna 'nota' para 'nota_media'

filmes_com_media

"""## Desafio 3 do [Guilherme Silveira](https://twitter.com/guilhermecaelum)

Colocar o número de avaliações por filme, isto é, não só a média mas o TOTAL de votos por filme.
"""

total_notas = avaliacoes.groupby('filmeId')['nota'].count() #Obtendo o total de notas por filme
total_notas.head(10)

total_notas.name = 'total_votos'
filmes_com_media_e_total = filmes_com_media.join(total_notas, on='filmeId')
filmes_com_media_e_total.head(10)

"""## Desafio 4 do [Thiago Gonçalves](https://twitter.com/tgcsantos)


Arredondar as médias (coluna de nota média) para duas casas decimais.
"""

filmes_com_media.nota_media = filmes_com_media.nota_media.round(2) #Arredondando as médias com 2 casas decimais
filmes_com_media.head(10)

"""## Desafio 5 do [Allan Spadini](https://twitter.com/allanspadini)

Descobrir os generos dos filmes (quais são eles, únicos). (esse aqui o bicho pega)
"""

generos_distintos = []

for generos in filmes['generos'].str.split('|'):
  for genero in generos:
    if genero not in generos_distintos:
      generos_distintos.append(genero)
generos_distintos

"""## Desafio 6 da [Thais André](https://twitter.com/thais_tandre)

Contar o número de aparições de cada genero.
"""

qte_generos = {genero : 0 for genero in generos_distintos}

for generos in filmes['generos'].str.split('|'):
  for genero in generos:
    qte_generos[genero] = qte_generos[genero] + 1

qte_generos

"""## Desafio 7 do [Guilherme Silveira](https://twitter.com/guilhermecaelum)

Plotar o gráfico de aparições de cada genero. Pode ser um gráfico de tipo igual a barra.
"""

import matplotlib.pyplot as plt

plt.figure(figsize=(20, 5))
plt.bar(qte_generos.keys(), qte_generos.values())

"""#Não esqueça de compartilhar a solução dos seus desafios com nossos instrutores, seja no twitter ou linkedin. Boa sorte!"""



"""## AULA 2"""

#Solução desafio 6

# filmes['generos'].str.get_dummies('|') #Quebrando a coluna gêneros que anteriormente estava retornando uma string separada por pipe (|) utilizando dummies
filmes['generos'].str.get_dummies('|').sum() #Contando o número de gêneros de filmes verticalmente 
# filmes['generos'].str.get_dummies('|').sum(axis=1) #Contando o número de gêneros de filmes baseado na horizontal
# filmes['generos'].str.get_dummies('|').sum(axis=1).value_counts()

#Ordenando gêneros em ordem decrescente de valores
filmes['generos'].str.get_dummies('|').sum().sort_values(ascending=False)

filmes.index #Acessando a idexação de registros de um dataframe (começa com 0 e termina em 9742 (exclusive))

filmes.values #Acessando todos os valores de um dataframe

filmes

filmes['generos'].str.get_dummies('|').sum().sort_index() #Ordenando em ordem alfabética de gêneros

#Plotando gráfico de aparições de gêneros (pizza = pie)
filmes['generos'].str.get_dummies('|').sum().sort_values(ascending=False).plot(kind='pie', 
                                                                               title='Categoria de filmes e suas presenças relativas',
                                                                               figsize = (8,8))

#Plotando gráfico de aparições de gêneros (barra) - Solução do desafio 7
filmes['generos'].str.get_dummies('|').sum().sort_values(ascending=False).plot(kind='bar', 
                                                                               title='Categoria de filmes e suas presenças relativas',
                                                                               figsize = (16,16))

import seaborn as sns
sns.set_style('whitegrid') #Colocando linha horizontal no gráfico para melhor visualização de quantos filmes aparecem por gênero
filmes_por_genero = filmes['generos'].str.get_dummies('|').sum().sort_values(ascending=False) 
plt.figure(figsize=(20, 16))

sns.barplot(x=filmes_por_genero.index,
            y=filmes_por_genero.values,
            palette=sns.color_palette('BuGn_r', n_colors=len(filmes_por_genero) + 4))

plt.show()

"""## Desafio 1: Rotacionar os thicks (os nomes dos gêneros)"""

notas_do_filme_1 = avaliacoes.query('filmeId==1')['nota']
print(notas_do_filme_1.mean())
notas_do_filme_1.plot(kind='hist')

notas_do_filme_2 = avaliacoes.query('filmeId==2')['nota']
print(notas_do_filme_2.mean())
notas_do_filme_2.plot(kind='hist')

notas_do_filme_2.describe()

notas_do_filme_1.describe()

#Obtendo a média por filme
avaliacoes.groupby('filmeId').mean()

filmes_com_media.sort_values('nota', ascending=False)[2450:2500]

"""##Desafio 2: comparar outros filmes com notas próximas e achar distribuições bem diferentes"""

def plot_filme(n):
  notas_do_filme = avaliacoes.query(f'filmeId=={n}')['nota']
  notas_do_filme.plot(kind='hist')
  plt.show()
  notas_do_filme.plot.box()
  plt.show()
  return notas_do_filme.describe()

plot_filme(919)

plot_filme(46578)

#Obtendo boxplot das notas dos 4 filmes selecionados (id 1, id 2, id 919 e id 46578)
sns.boxplot(data = avaliacoes.query('filmeId in [1,2,919,46578]'), x = 'filmeId', y='nota')

"""## Desafio 3: Criar o boxplot dos 10 filmes com mais votos (não é com maior média, é com mais votos!)

## Desafio 4: O boxplot estar num tamanho adequado e com os NOMES dos filmes nos thicks

## Desafio 5: Calcular moda, mediana e mediana dos filmes. Tentar encontrar filmes com moda próxima de 0.5, 3 e 5.

## Desafio 6: Plotar o boxplot e o histograma um do lado do outro (na mesma figura ou em figuras distintas)

## Desafio 7: Gráfico de notas médias por ano
"""